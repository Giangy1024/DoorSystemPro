WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.440
[音乐播放]

00:00:03.440 --> 00:00:17.320
大家好，欢迎回到虚幻引擎 5 蓝图精通，

00:00:17.320 --> 00:00:22.000
门系统和交互式门户。

00:00:22.000 --> 00:00:26.920
之前，我们最终完成了设计部分

00:00:26.920 --> 00:00:30.200
我们的小部件，我已经关闭了。

00:00:30.200 --> 00:00:31.480
所以，我没有。

00:00:31.480 --> 00:00:32.280
这里是。

00:00:32.280 --> 00:00:35.200
我们创建了一个小部件蓝图。

00:00:35.200 --> 00:00:37.240
我们将其命名为WG Door。

00:00:37.240 --> 00:00:41.720
我们在层次结构中添加了一个画布面板。

00:00:41.720 --> 00:00:44.640
嗯，这是我没有解释清楚的一点。

00:00:44.640 --> 00:00:46.920
在这里，我们有等级制度，

00:00:46.920 --> 00:00:51.360
它向我们展示了小部件内部有哪些元素。

00:00:51.360 --> 00:00:55.880
它有点像蓝图中的组件选项卡，

00:00:55.880 --> 00:00:57.880
但对于小部件而言。

00:00:57.880 --> 00:01:03.200
这里的层次结构告诉我们哪个小部件是第一个，第二个，

00:01:03.200 --> 00:01:05.960
基本上，哪个属于谁。

00:01:05.960 --> 00:01:08.560
另外，我没有对水平框进行过多的解释。

00:01:08.560 --> 00:01:10.760
我认为它是不言自明的。

00:01:10.760 --> 00:01:14.200
它允许小部件水平布局。

00:01:14.200 --> 00:01:18.520
如果我们将鼠标悬停在--允许小部件进行布局

00:01:18.520 --> 00:01:20.520
水平流动。

00:01:20.520 --> 00:01:24.400
如果我们悬停任何内容，如果我们选择任何内容并悬停它，

00:01:24.400 --> 00:01:31.280
它会给我们一个关于它的工具提示。

00:01:31.280 --> 00:01:33.520
来吧，做这件事。

00:01:33.520 --> 00:01:36.840
如果你只是不想的话。

00:01:36.840 --> 00:01:38.920
是的，基本上，在调色板中，

00:01:38.920 --> 00:01:41.080
更容易看到工具提示。

00:01:41.080 --> 00:01:44.840
这里，它必须位于图标本身上。

00:01:44.840 --> 00:01:46.320
我们已经创建了小部件。

00:01:46.320 --> 00:01:50.080
我们已经通过以下方式添加到我们的视口中——我们创建了它

00:01:50.080 --> 00:01:53.600
并通过游戏模式将其添加到视口。

00:01:53.600 --> 00:01:56.840
但是在开始播放事件时，我们创建了小部件，

00:01:56.840 --> 00:01:59.560
然后我们将其添加到视口。

00:01:59.560 --> 00:02:01.160
现在，我们将其托管到游戏模式

00:02:01.160 --> 00:02:03.440
因为它将在我们的各个层面共享，

00:02:03.440 --> 00:02:07.400
我们希望这个小部件存在于每一个级别。

00:02:07.400 --> 00:02:12.880
但我们不想在视口上添加小部件

00:02:12.880 --> 00:02:14.240
当游戏开始时。

00:02:14.240 --> 00:02:17.200
我们希望在调用它时将其添加到视口。

00:02:17.200 --> 00:02:21.760
我们要做的是将其提升为一个变量，

00:02:21.760 --> 00:02:23.360
是我们的小部件参考。

00:02:23.360 --> 00:02:25.960
当我们创建时，我们会得到一个返回值，

00:02:25.960 --> 00:02:28.920
这是对我们所创造内容的引用。

00:02:28.920 --> 00:02:35.120
我将把它命名为 WG.ref。

00:02:35.120 --> 00:02:37.200
正如你所见，主题与参考

00:02:37.200 --> 00:02:40.760
在编程中有点重要。

00:02:40.760 --> 00:02:44.320
致电参考，找到引用某事的方法

00:02:44.320 --> 00:02:46.720
就像我们在关卡蓝图中那样

00:02:46.720 --> 00:02:49.400
我们引用触发框的时候

00:02:49.400 --> 00:02:52.480
我们有对另一个组件的引用，它

00:02:52.480 --> 00:02:55.360
我们询问它是否有标签。

00:02:55.360 --> 00:02:57.480
参考文献是一回事。

00:02:57.480 --> 00:03:01.640
如果你愿意的话，参考是阿尔法和欧米茄，

00:03:01.640 --> 00:03:04.680
面向对象编程。

00:03:04.680 --> 00:03:08.120
现在，我们已经存储了该小部件的引用。

00:03:08.120 --> 00:03:10.040
因此我们要创建一个自定义事件。

00:03:10.040 --> 00:03:18.960
我将把它命名为 add.widget。

00:03:18.960 --> 00:03:21.360
我要将它连接到添加视口。

00:03:21.360 --> 00:03:23.840
我要把参考资料带到这里

00:03:23.840 --> 00:03:25.480
并将其连接到目标。

00:03:25.480 --> 00:03:27.600
因为如果我们只是添加到视口，

00:03:27.600 --> 00:03:31.320
它可能会触发错误或不执行任何操作，

00:03:31.320 --> 00:03:33.320
因为没有目标。

00:03:33.320 --> 00:03:35.920
因为目标自我意味着游戏模式。

00:03:35.920 --> 00:03:38.920
它不是一个小部件，因此无法将其添加到视口。

00:03:38.920 --> 00:03:42.240
但是小部件引用，它可以被添加到视口，

00:03:42.240 --> 00:03:44.600
这将正常工作。

00:03:44.600 --> 00:03:50.920
现在，我们要做的是创建另一个自定义事件

00:03:50.920 --> 00:03:56.640
并将其命名为 remove.widget。

00:03:56.640 --> 00:03:59.080
我要从小部件引用中拖出一条电缆

00:03:59.080 --> 00:04:02.360
并说从父级中删除。

00:04:02.360 --> 00:04:05.960
这是我们从视口中移除小部件的方式，

00:04:05.960 --> 00:04:07.080
其中一种方式。

00:04:07.080 --> 00:04:10.040
那么让我们来利用这两个功能。

00:04:10.040 --> 00:04:13.160
我们去单向门吧。

00:04:13.160 --> 00:04:15.400
让我们进入事件图。

00:04:15.400 --> 00:04:18.680
让我们来看看碰撞。

00:04:18.680 --> 00:04:21.400
所以当我们发生碰撞并开始重叠时，

00:04:21.400 --> 00:04:24.120
我们应该展示我们的小部件。

00:04:24.120 --> 00:04:27.480
要调用此功能，我需要进入游戏模式。

00:04:27.480 --> 00:04:30.480
所以我需要对游戏模式的参考。

00:04:30.480 --> 00:04:35.120
值得庆幸的是，虚幻引擎有一个很好的方法来获取游戏模式。

00:04:35.120 --> 00:04:39.280
这被称为获取游戏模式。

00:04:39.280 --> 00:04:42.400
但这会返回一个通用值。

00:04:42.400 --> 00:04:44.000
我们有特定的游戏模式。

00:04:44.000 --> 00:04:47.080
我们有第三人称游戏模式，

00:04:47.080 --> 00:04:50.080
或者我们有门游戏模式，或者我们

00:04:50.080 --> 00:04:52.200
可以有任意一种游戏模式。

00:04:52.200 --> 00:04:57.240
这仅返回通用游戏模式，

00:04:57.240 --> 00:05:00.080
基于游戏模式的对象引用。

00:05:00.080 --> 00:05:04.600
为了检查它是否是我们的游戏模式，我们需要进行投射。

00:05:04.600 --> 00:05:10.600
所以我们要转换到第三人称游戏模式。

00:05:10.600 --> 00:05:13.520
正如我们所说，演员正在问一些事情，

00:05:13.520 --> 00:05:16.000
基本上，你是这个东西吗？

00:05:16.000 --> 00:05:20.360
这个物体是这种物体吗？

00:05:20.360 --> 00:05:23.400
所以我要转换成纯强制类型转换，这样

00:05:23.400 --> 00:05:29.080
移除执行引脚并使其变得更容易一些。

00:05:29.080 --> 00:05:33.680
如果我们成功了，我们的游戏模式就是游戏模式，

00:05:33.680 --> 00:05:39.280
因为其成功程度就像纯粹的演员表演一样。

00:05:39.280 --> 00:05:42.240
这就像投掷失败，投掷成功一样。

00:05:42.240 --> 00:05:49.480
现在我们有一个布尔值来告诉我们它是否成功。

00:05:49.480 --> 00:05:53.600
所以如果我们成功了，那么我们就可以得到一些信息。

00:05:53.600 --> 00:05:55.720
我们可以得到一些函数和事件

00:05:55.720 --> 00:05:57.880
来自第三人称游戏模式。

00:05:57.880 --> 00:06:07.680
我们现在想要的事件是在这里添加门小部件。

00:06:07.680 --> 00:06:10.560
我只需拖另一根电缆就可以说，

00:06:10.560 --> 00:06:15.280
拆下门小部件并将其连接到这里。

00:06:15.280 --> 00:06:21.800
我将编译并保存，然后我们去测试一下。

00:06:21.800 --> 00:06:23.080
我要去第一扇门。

00:06:23.080 --> 00:06:23.880
它開了。

00:06:23.880 --> 00:06:25.200
第二扇门。

00:06:25.200 --> 00:06:27.800
我们有一个小部件。

00:06:27.800 --> 00:06:30.120
并且它正在被移除。

00:06:30.120 --> 00:06:30.720
好的。

00:06:30.720 --> 00:06:33.760
但问题是我们的 widget 没有

00:06:33.760 --> 00:06:38.080
与其应该表达的意思相符。

00:06:38.080 --> 00:06:41.000
就像现在，它应该说是开放。

00:06:41.000 --> 00:06:44.640
而现在，它应该说接近，这是正确的。

00:06:44.640 --> 00:06:46.080
但它只有 50% 正确。

00:06:46.080 --> 00:06:47.640
它并不总是正确的。

00:06:47.640 --> 00:06:49.360
因此让我们修复这个问题。

00:06:49.360 --> 00:06:53.000
为了做到这一点，我们要玩第三人称游戏

00:06:53.000 --> 00:06:58.760
模式，我们将创建一个函数。

00:06:58.760 --> 00:07:01.400
那么函数是什么？

00:07:01.400 --> 00:07:06.400
基本上，它是一组动作或逻辑，如果你愿意的话，

00:07:06.400 --> 00:07:08.040
可重复使用。

00:07:08.040 --> 00:07:11.400
可以多次使用，也可以调用

00:07:11.400 --> 00:07:13.800
同时多次。

00:07:13.800 --> 00:07:17.800
并且它每次都会运行特定的任务。

00:07:17.800 --> 00:07:20.160
就像一个事件，如果它再次被调用，

00:07:20.160 --> 00:07:24.680
他们通常会排队等待新来电，

00:07:24.680 --> 00:07:29.040
而函数将再次运行。

00:07:29.040 --> 00:07:32.720
举个实际的例子

00:07:32.720 --> 00:07:38.280
会发生多次重叠碰撞。

00:07:38.280 --> 00:07:41.400
比如说，很多子弹击中了你

00:07:41.400 --> 00:07:45.080
在同一秒的瞬间。

00:07:45.080 --> 00:07:49.520
它将按照先命中的顺序进行排队

00:07:49.520 --> 00:07:52.600
哪一个第二次击中，等等，

00:07:52.600 --> 00:07:56.680
如果是函数，它们都会运行

00:07:56.680 --> 00:07:57.680
立即地。

00:07:57.680 --> 00:08:02.040
它们将被堆叠并立即执行。

00:08:02.040 --> 00:08:04.400
所以基本上我们可以创建一个活动，

00:08:04.400 --> 00:08:08.720
但针对这种情况，我们创建了一个函数。

00:08:08.720 --> 00:08:10.520
现在，关于函数还有一件事

00:08:10.520 --> 00:08:12.800
当然，他们有投入，

00:08:12.800 --> 00:08:15.240
正如我们在细节中看到的那样，但他们也

00:08:15.240 --> 00:08:16.760
可以有输出。

00:08:16.760 --> 00:08:18.760
例如，如果我想要某样东西

00:08:18.760 --> 00:08:21.760
想知道它是否成功，我

00:08:21.760 --> 00:08:24.680
可以有一个布尔值输出。

00:08:24.680 --> 00:08:27.600
正如您所见，它创建了一个返回节点。

00:08:27.600 --> 00:08:33.400
这个布尔值可能是真也可能是假，例如，

00:08:33.400 --> 00:08:37.120
我在这里所做的事情是否成功。

00:08:37.120 --> 00:08:38.400
我要删除这个，而且我

00:08:38.400 --> 00:08:41.440
将删除返回节点，因为我们不需要它。

00:08:41.440 --> 00:08:43.960
我们将进行编译并保存。

00:08:43.960 --> 00:08:46.880
也许还有关于函数的一个细节，

00:08:46.880 --> 00:08:48.960
就这样吧。

00:08:48.960 --> 00:08:53.200
函数，它们内部不能包含时间事物。

00:08:53.200 --> 00:08:55.880
它们可以调用外部定时的东西，

00:08:55.880 --> 00:08:58.320
但他们不能在这里耽搁。

00:08:58.320 --> 00:08:59.960
我们这里无法有时间表。

00:08:59.960 --> 00:09:02.360
我们不能有计时器。

00:09:02.360 --> 00:09:07.160
所以时间是不能以函数形式存在的。

00:09:07.160 --> 00:09:09.840
现在，我们的函数应该做什么？

00:09:09.840 --> 00:09:11.880
我们将其称为 updateWidgetText。

00:09:11.880 --> 00:09:20.360
我们需要一个字符串类型的新输入。

00:09:20.360 --> 00:09:23.880
我将把它命名为 widgetText。

00:09:23.880 --> 00:09:28.360
现在，我们要做的就是

00:09:28.360 --> 00:09:31.120
获取我们的 widget.reference。

00:09:31.120 --> 00:09:32.640
我要到这里来拿到它。

00:09:32.640 --> 00:09:37.440
我要收到短信了。

00:09:37.440 --> 00:09:39.680
实际上，让我们转到我们的小部件。

00:09:39.680 --> 00:09:41.000
我们去找我们的设计师吧。

00:09:41.000 --> 00:09:44.400
现在我们要修改这里的文字，

00:09:44.400 --> 00:09:46.720
表示关闭的文字。

00:09:46.720 --> 00:09:48.800
如果我们仔细观察细节，

00:09:48.800 --> 00:09:53.040
我们可以放一个名字，或者我们实际上可以把它放在这里。

00:09:53.040 --> 00:09:54.800
但我会选择留在这里。

00:09:54.800 --> 00:10:02.360
我们将此称为“widgetText”，即“我的小部件文本”。

00:10:02.360 --> 00:10:09.320
现在，旁边有一个名为“is variable”的按钮。

00:10:09.320 --> 00:10:13.760
如果没有被点击，那么就意味着它是静态的。

00:10:13.760 --> 00:10:15.600
它不可被修改。

00:10:15.600 --> 00:10:18.160
而如果我点击的是变量，它

00:10:18.160 --> 00:10:20.760
可以通过代码修改。

00:10:20.760 --> 00:10:22.240
这有很多原因

00:10:22.240 --> 00:10:23.800
在幕后发生。

00:10:23.800 --> 00:10:27.840
但我们不要谈论太多细节。

00:10:27.840 --> 00:10:33.120
让我们再次进入游戏模式，不是偶数图，

00:10:33.120 --> 00:10:36.840
在我们的游戏模式中的函数widgetUpdate中。

00:10:36.840 --> 00:10:41.440
我们将获取我的小部件文本。

00:10:41.440 --> 00:10:45.000
从这里开始，我们要设置文本

00:10:45.000 --> 00:10:52.640
正如我们对 BP 流文本中的文本渲染所做的那样。

00:10:52.640 --> 00:10:55.880
我要将其连接到——啊，这是一段文本。

00:10:55.880 --> 00:10:57.280
是的。

00:10:57.280 --> 00:11:01.440
我们可以将此字符串更改为文本

00:11:01.440 --> 00:11:03.120
并可直接连接。

00:11:03.120 --> 00:11:05.800
如果我将其保留为字符串，则无关紧要。

00:11:05.800 --> 00:11:08.800
它会自动将其翻译为文本字符串。

00:11:08.800 --> 00:11:15.320
但为什么不让这部分更清楚一点呢？

00:11:15.320 --> 00:11:21.280
我要将它改为文本并在这里连接。

00:11:21.280 --> 00:11:27.280
因此我们有一个可以改变文本的函数。

00:11:27.280 --> 00:11:30.320
我需要编译该小部件。

00:11:30.320 --> 00:11:32.480
因为我们把它变成了变量，

00:11:32.480 --> 00:11:34.360
它需要被编译。

00:11:34.360 --> 00:11:39.560
我们也保存一下，现在就好了。

00:11:39.560 --> 00:11:42.480
我认为这是一个很好的停靠点。

00:11:42.480 --> 00:11:44.240
我们下期继续，

00:11:44.240 --> 00:11:47.160
实现这一新功能。

00:11:47.160 --> 00:11:49.320
暂时再见。

00:11:49.320 --> 00:11:52.680
[音乐播放]

00:11:52.680 --> 00:11:56.040
[音乐播放]

00:11:56.440 --> 00:11:58.800
[音乐播放]

