WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:18.600
您好，欢迎回到虚幻引擎 5、蓝图掌握、门系统和互动

00:00:18.600 --> 00:00:19.600
门户。

00:00:19.600 --> 00:00:27.680
之前，我们添加了添加门部件或删除门部件的功能

00:00:27.680 --> 00:00:33.360
根据我们是否与门发生碰撞。

00:00:33.360 --> 00:00:39.360
为此，我们创建了两个自定义事件，并使用了“添加到视口”和“从视口中删除”

00:00:39.360 --> 00:00:45.040
父级并将它们连接到我们在 Begin 中存储的小部件的引用

00:00:45.040 --> 00:00:46.040
玩。

00:00:46.040 --> 00:00:55.280
然后我们来到我们的门，BP单向门，并开始重叠和结束重叠事件

00:00:55.280 --> 00:01:03.360
碰撞，我们添加了 Add Door 小部件，并通过获取

00:01:03.360 --> 00:01:07.440
游戏模式并转换为第三人称游戏模式。

00:01:07.440 --> 00:01:13.760
接下来，我们在第三人称游戏模式中创建了一个函数，我们将其称为“更新小部件文本”。

00:01:13.760 --> 00:01:20.200
现在，此函数有一个小部件文本输入，它通过引用设置文本

00:01:20.200 --> 00:01:25.400
门小部件，我们从中获取了我的小部件文本。

00:01:25.400 --> 00:01:31.600
现在，让我们继续创建更新小部件文本的系统。

00:01:31.600 --> 00:01:38.000
为了做到这一点，让我们进入单向门并创建另一个函数，我们将调用它

00:01:38.000 --> 00:01:42.680
再次更新小部件文本。

00:01:42.680 --> 00:01:52.960
在这个函数中，我们将获得我们的游戏模式，我们可以获取游戏模式，我们可以

00:01:52.960 --> 00:01:58.640
转换为第三人称游戏模式并转换为纯粹游戏模式。

00:01:58.640 --> 00:02:03.640
但是，由于我们在这个蓝图中经常使用它，我们可以去我们的

00:02:03.640 --> 00:02:06.880
开始游戏，我们可以从这里复制此代码。

00:02:06.880 --> 00:02:11.200
实际上，我只是要从这里剪切这段代码。

00:02:11.200 --> 00:02:15.800
转到开始播放，将其粘贴到这里。

00:02:15.800 --> 00:02:23.480
这次我将把它作为一个转换节点进行连接，并将其提升为一个变量。

00:02:23.480 --> 00:02:28.280
如你所见，Unreal 已将其命名为 BP 第三人称游戏模式。

00:02:28.280 --> 00:02:29.280
很方便。

00:02:29.280 --> 00:02:35.280
我要编译，它说它无法编译，因为这两个目标

00:02:35.280 --> 00:02:37.680
功能已断开。

00:02:37.680 --> 00:02:43.600
这也是我之前的意思，目标是指谁应该做这件事。

00:02:43.600 --> 00:02:48.640
并且目前自身没有添加门部件的功能。

00:02:48.640 --> 00:02:54.700
即使确实如此，该函数的目标、预定目标也是

00:02:54.700 --> 00:02:56.120
BP 第三人称。

00:02:56.120 --> 00:03:04.000
所以即使我创建自定义事件，添加门小部件。

00:03:04.000 --> 00:03:10.080
您可以看到这仍然会出现错误，因为目标是 BP。

00:03:10.080 --> 00:03:13.560
我们从游戏模式中调用了这个。

00:03:13.560 --> 00:03:17.800
为了消除错误，我们只需将变量中的引用带到这里

00:03:17.800 --> 00:03:22.520
我们要把这个连接到这里，把这个连接到这里。

00:03:22.520 --> 00:03:26.720
而且我认为这个字符串变量没有在任何地方使用。

00:03:26.720 --> 00:03:28.720
我们总能找到参考。

00:03:28.720 --> 00:03:29.720
姓名。

00:03:29.720 --> 00:03:32.720
不，它没有在任何地方使用。

00:03:32.720 --> 00:03:36.760
我要删除它并重新编译。

00:03:36.760 --> 00:03:39.480
现在错误已经消失。

00:03:39.480 --> 00:03:42.560
让我们回到我们的小部件更新小部件文本。

00:03:42.560 --> 00:03:44.160
现在我们不需要这个。

00:03:44.160 --> 00:03:49.800
我们可以提供一款游戏作为参考，因为它存储了游戏模式，

00:03:49.800 --> 00:03:51.800
游戏模式的实例。

00:03:51.800 --> 00:03:57.640
我们将更新小部件文本。

00:03:57.640 --> 00:04:04.960
现在我们有了函数，我们需要填充它将要显示什么样的文本

00:04:04.960 --> 00:04:06.920
出現。

00:04:06.920 --> 00:04:10.560
因此要做到这一点，我们需要获取门的状态。

00:04:10.560 --> 00:04:20.520
我们要打开门的状态，因为这是控制，我们实际上可以

00:04:20.520 --> 00:04:21.800
让我们展示另一个节点。

00:04:21.800 --> 00:04:24.320
这样就好多了。

00:04:24.320 --> 00:04:25.560
让我们在这里连接它。

00:04:25.560 --> 00:04:30.680
还有一个节点，我们可以创建一些文本，然后在那里添加文本并设置

00:04:30.680 --> 00:04:31.960
那段文字。

00:04:31.960 --> 00:04:37.560
我们可以将其基本上处理为字符串或者文本。

00:04:37.560 --> 00:04:50.280
我们可以拥有一堆基于 switch 的 setter。

00:04:50.280 --> 00:04:54.640
因此，我们可以就这个案子、这个案子、这个案子，

00:04:54.640 --> 00:04:57.880
然后将该文本连接到这里。

00:04:57.880 --> 00:05:03.000
现在我们可以做的另一件事是，我们可以在特定节点上使用另一个节点

00:05:03.000 --> 00:05:08.880
这被称为选择的变量。

00:05:08.880 --> 00:05:15.760
并且这个选择节点有一个通配符索引，也就是说它可以成为某些类型的变量。

00:05:15.760 --> 00:05:19.200
所以如果我按下这里，我们就可以看到它可以变成的变量类型。

00:05:19.200 --> 00:05:22.120
正如您所见，它可以成为一个枚举。

00:05:22.120 --> 00:05:29.720
所以这意味着我可以在这里连接它，这样我就可以为每个元素进行选择，对于每个

00:05:29.720 --> 00:05:32.100
基本上，是枚举器。

00:05:32.100 --> 00:05:35.680
因此，当枚举器打开时，它会给我这个选择。

00:05:35.680 --> 00:05:38.340
当它关闭时，它会给我这个选择。

00:05:38.340 --> 00:05:43.080
现在让我们填写每个案例所需的内容。

00:05:43.080 --> 00:05:46.960
为了开放，我们需要关闭。

00:05:46.960 --> 00:05:50.840
为了关闭，我们需要打开。

00:05:50.840 --> 00:05:55.920
对于另外两个，我们不需要任何东西，因为我们当时没有与门互动

00:05:55.920 --> 00:05:56.920
观点。

00:05:56.920 --> 00:06:00.480
所以我们要编译、保存，然后去测试它。

00:06:00.480 --> 00:06:09.560
实际上，不是的，我们需要先调用它，因为仅仅创建它并不意味着我们调用了它。

00:06:09.560 --> 00:06:12.000
小部件何时应更新？

00:06:12.000 --> 00:06:16.400
当然，在我们将其添加到视口之前。

00:06:16.400 --> 00:06:18.480
因此我将直接从函数中跳出。

00:06:18.480 --> 00:06:24.720
我要将它拖放到这里并将其连接到这里。

00:06:24.720 --> 00:06:31.280
我将复制粘贴它并将其连接到下面。

00:06:31.280 --> 00:06:40.240
并且小部件也应该在我们应该做的下一步时更新

00:06:40.240 --> 00:06:44.800
每当我们改变状态时就会进行更新。

00:06:44.800 --> 00:06:51.560
因为我们的状态会影响小部件应该表达的内容。

00:06:51.560 --> 00:06:57.480
所以我要把它拖放在这里，然后将两根电缆连接在这里。

00:06:57.480 --> 00:07:03.760
正如您所看到的，我可以有两个执行连接到一个节点。

00:07:03.760 --> 00:07:05.000
现在我要做同样的事情。

00:07:05.000 --> 00:07:10.080
我要将其复制并粘贴到这两个执行中。

00:07:10.080 --> 00:07:17.160
因此，一个是更新，另一个是完成。

00:07:17.160 --> 00:07:21.160
现在我们来测试一下。

00:07:21.160 --> 00:07:24.160
现在按下播放键。

00:07:24.160 --> 00:07:27.160
它開了。

00:07:27.160 --> 00:07:31.160
打开。

00:07:31.160 --> 00:07:36.760
我们有那个 E，但它并没有按照我们想要的方式运行。

00:07:36.760 --> 00:07:44.120
它并没有消失，但是，是的，让我们修复它。

00:07:44.120 --> 00:07:48.680
所以我们要做的事情非常简单。

00:07:48.680 --> 00:07:56.840
我们不会在时间轴更新时更新小部件，而是

00:07:56.840 --> 00:08:00.020
删除该小部件。

00:08:00.020 --> 00:08:03.160
所以我要把这段代码复制到这里。

00:08:03.160 --> 00:08:16.880
BP第三人称游戏模式并删除门并将其粘贴在时间线的末尾，

00:08:16.880 --> 00:08:19.000
时间线的更新。

00:08:19.000 --> 00:08:27.880
我们需要做的下一件事是更新此小部件文本后，我们还应该将其添加到

00:08:27.880 --> 00:08:28.880
再次查看视口。

00:08:28.880 --> 00:08:36.640
哎呀，我按了粘贴，我要按复制，然后粘贴到这里并连接这个

00:08:36.640 --> 00:08:41.840
这里。

00:08:41.840 --> 00:08:43.280
这应该可行。

00:08:43.280 --> 00:08:52.040
我们去测试一下吧。

00:08:52.040 --> 00:08:55.040
并且它有效。

00:08:55.040 --> 00:08:56.800
惊人的。

00:08:56.800 --> 00:08:58.320
我想这就是这个的全部了。

00:08:58.320 --> 00:08:59.320
我接下来要去看你。

00:08:59.320 --> 00:08:59.320
再见。

00:09:00.320 --> 00:09:10.320
[音乐]

